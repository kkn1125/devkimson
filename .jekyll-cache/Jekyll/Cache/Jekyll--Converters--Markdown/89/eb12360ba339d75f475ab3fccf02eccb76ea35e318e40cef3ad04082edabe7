I"//<h1 id="파일-구조-도식화">파일 구조 도식화</h1>

<p>블로그에 포스팅을 작성하다 보면 파일 트리를 설명할 때 이미지보다 텍스트로 표현을 해야 할 때가 있습니다.</p>

<p>이미지를 사용하면 간단하게 해결되지만 번거로울 때가 있고, 이미지도 올려야 하고, 이미지가 늘어날수록 페이지가 느려지는 감이 있습니다.</p>

<p>이전에 바닐라 자바스크립트로 구현했던 마크다운 파서의 <code class="language-plaintext highlighter-rouge">블록 쿼터</code>와 <code class="language-plaintext highlighter-rouge">리스트</code> 들여쓰기와 관련 있지 않을까 생각하면서 시작했습니다.</p>

<h2 id="목적">목적</h2>

<p>이미지 사용, 기호를 하나씩 붙여가며 수작업하는 것을 덜기 위해서 만들게 되었습니다.</p>

<h2 id="개발-과정">개발 과정</h2>

<p>이번에는 테스트 자동화 및 단위 테스트를 습관화하기 위해 테스트 코드 작성에 초점을 두어 작성했는데요. 기능 개발에 있어서 이전까지는 테스트 코드의 중요성을 크게 느끼지 못했습니다.</p>

<p>개발하면서 테스트 코드를 통해서 어디에서 오류가 발생하고, 클린코드의 중요성을 한 번 더 느끼면서 최대한 군더더기 없이 코드를 짜는 데 노력했습니다.</p>

<p>코드 컨벤션을 지키면서, 파일 별로 버전과 수정시간, 작성 시간, 코드별 간단한 주석 등에 더 신경 썼습니다. 혼자 하는 작업이지만 누군가 볼 수도 있고, 나중에 작업하기 위해 볼 것이기 때문에 공들여 작성했습니다.</p>

<p>먼저, 아래 내용의 이해를 돕기위해 <code class="language-plaintext highlighter-rouge">Tree Parser</code> 일부 내용을 설명하겠습니다.</p>

<ol>
  <li>Branch = 파일 트리를 구조화하는데 필요한 기호를 말합니다. ex) &#8220;└── root&#8221;</li>
  <li>First, Second, Third = 브랜치 기호의 인덱스를 말합니다. ex) first:&#8221;└&#8221;, second:&#8221;─&#8221;, third:&#8221;─&#8221;</li>
  <li>vertical = 파일 트리 구조화에서 같은 위치(레벨)에 존재하는 파일 디렉토리를 잇는 선을 말합니다.ex) <br />
　│　 &lt;&#8212;&#8211; vertical <br />
　└── brotherDirectory</li>
</ol>

<h3 id="pipeline-개념-활용">Pipeline 개념 활용</h3>

<p>단계별로 파싱하는 개념을 생각했습니다. 단계별로 처리하게 되면 개인적으로 생각하는 이점은 흐름을 코드 단위로 볼 때 이해가 쉽고, 어디서 어떤 오류가 났는지 명확하게 볼 수 있다는 점이라 생각합니다. 반면 단점은 의존성이 커지는 것이라 생각됩니다.</p>

<h4 id="문자열에서-배열로">문자열에서 배열로</h4>

<p>위에서 말하는 <code class="language-plaintext highlighter-rouge">pipeline</code> 개념은 아래와 같습니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="c1">// 트리 파서 코드 일부</span>

<span class="cm">/**
 * 원문 파싱 후 브랜치를 그림
 * 
 * @param {string} source 
 * @returns {string[]}
 */</span>
<span class="k">this</span><span class="p">.</span><span class="nx">parse</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">convertedLines</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">stringToArray</span><span class="p">(</span><span class="nx">source</span><span class="p">);</span>
    <span class="nx">parsedLines</span>    <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">parseLines</span><span class="p">(</span><span class="nx">convertedLines</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>위 코드는 실제 <code class="language-plaintext highlighter-rouge">Tree Parser</code>의 일부입니다. <code class="language-plaintext highlighter-rouge">stringToArray</code>와 <code class="language-plaintext highlighter-rouge">parseLines</code> 메서드는 더 많은 메서드 호출 구문을 담고 있습니다. 호출되는 메서드는 모두 단계별로 실행되어 결과물이 아래로 전달되는 방식입니다.</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="c1">// 트리 파서 코드 일부</span>

<span class="cm">/**
 * 원문 소스를 공백 제거된 줄(line) 단위 배열로 변환
 * @param {string} source 
 * @returns {string[]}
 */</span>
<span class="k">this</span><span class="p">.</span><span class="nx">stringToArray</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">source</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">trimSources</span>   <span class="o">=</span> <span class="nx">source</span><span class="p">.</span><span class="nx">trim</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">splitedLines</span>  <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">separateLine</span><span class="p">(</span><span class="nx">trimSources</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">filteredLines</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">filterEmptyLine</span><span class="p">(</span><span class="nx">splitedLines</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">filteredLines</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">stringToArray</code> 메서드의 일부입니다. 여기서 생각했던 단계별 기능은 아래와 같습니다.</p>

<ol>
  <li>원문 텍스트 앞 뒤 공백 제거</li>
  <li>줄 단위로 분리</li>
  <li>줄 단위에서 공백이 있으면 삭제</li>
  <li>필터를 거친 배열 반환</li>
</ol>

<p>이름에서와 같이 딱 문자열에서 배열로 변환하는 작업만 합니다.</p>

<h4 id="라인-파싱">라인 파싱</h4>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="cm">/**
 * View 단에 출력하기 전 마지막 데이터 가공 상태 반환
 * @param {Object[]} lines 
 * @returns {Object[]}
 */</span>
<span class="k">this</span><span class="p">.</span><span class="nx">parseLines</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">convertedCountIndenceArray</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">countIndences</span><span class="p">(</span><span class="nx">lines</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">addedThirdBranchArray</span>      <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">addThirdBranch</span><span class="p">(</span><span class="nx">convertedCountIndenceArray</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">addedSecondBranchArray</span>     <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">addSecondBranch</span><span class="p">(</span><span class="nx">addedThirdBranchArray</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">addedFirstBranchArray</span>      <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">addFirstBranch</span><span class="p">(</span><span class="nx">addedSecondBranchArray</span><span class="p">);</span>

    <span class="k">return</span> <span class="nx">addedFirstBranchArray</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>라인 파싱단계인 <code class="language-plaintext highlighter-rouge">parseLines</code>는 <code class="language-plaintext highlighter-rouge">countIndences</code>메서드로 앞의 공백 개수를 먼저 분석합니다. 그 다음 <code class="language-plaintext highlighter-rouge">addThirdBranch</code>메서드로 파일 트리의 공통되는 선 기호를 그립니다.</p>

<p><code class="language-plaintext highlighter-rouge">add*</code> 메서드로 각 브랜치 부분을 적절한 요소를 판별해서 기호를 선정하는 작업을 하게 됩니다. 마지막으로 <code class="language-plaintext highlighter-rouge">FirstBranch</code>까지 파싱하면 반환합니다.</p>

<p>여기까지의 파싱 결과 타입은 <code class="language-plaintext highlighter-rouge">Object[]</code>입니다. 화면에 출력하는 메서드는 따로 있기 때문에 딱 여기까지의 일만 하고 나머지는 <code class="language-plaintext highlighter-rouge">View</code> 객체에 위임합니다.</p>

<blockquote>
  <p>브랜치가 무엇인지는 따로 설명 안 하겠습니다. 현재 포스팅의 상단 &#8220;개발 과정&#8221;에 설명되어 있으니 참고 바랍니다.</p>
</blockquote>

<h2 id="마무리">마무리</h2>

<p>만드는 과정에서 제일 힘들었던 문제가 &#8220;First Branch를 어떻게 정확히 결정시키는가&#8221; 였습니다. 지금 보면 간단한 원리이지만 방법을 모르는 때에는 뭐든 어렵게 느껴지는 것 같습니다.</p>

<p>트러블슈팅에 있어서 기존에 작성했던 로직을 모두 버리고 새로운 방법으로 접근 시도를 가끔 하는데요. 여러 방식으로 접근하다 보면 적합한 솔루션을 발견할 수 있고, 해당 솔루션으로 작업하다 보면 의외로 간단하게 문제를 해결하는 제 모습을 많이 봤습니다.</p>

<p>트리 파서의 내용이 궁금하시거나 사용해보고 싶은 분은 아래 링크를 참조하시기 바랍니다 🙇‍♂️</p>

<h2 id="개선-사항">개선 사항</h2>

<blockquote>
  <p>현재 개발된 결과물에서 필요한 사항을 기재한 내용입니다.
version v0.2.0</p>
</blockquote>

<ul>
  <li>커스터마이징 가능한 환경</li>
  <li>API 방식 지원</li>
  <li>실시간 변형 메서드 추가</li>
</ul>

<h3 id="demo-site-result">Demo site result</h3>

<p>├┬─This is a sample <br />
│├┬─sample child 1-1 <br />
││└──sample child 2-1 <br />
│└┬─sample child 1-2 <br />
│　└┬─sample child 2-2 <br />
│　　└┬─children <br />
│　　　└──children <br />
└┬─Other Parent <br />
　├┬─child <br />
　│├┬─child <br />
　││└──child <br />
　│├┬─test1 <br />
　││└──test2 <br />
　│└──test3 <br />
　└──test4</p>

<hr />

<p>📚 함께 보면 좋은 내용</p>

<p><a href="https://kkn1125.github.io/treeparser/" target="_blank">devkimson - tree parser::Demo Site</a></p>

<p><a href="https://github.com/kkn1125/treeparser/" target="_blank">devkimson - tree parser::Repository</a></p>
:ET